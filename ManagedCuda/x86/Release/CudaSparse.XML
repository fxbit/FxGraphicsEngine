<?xml version="1.0"?>
<doc>
    <assembly>
        <name>CudaSparse</name>
    </assembly>
    <members>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseException">
            <summary>
            An CudaSparseException is thrown, if any wrapped call to the CUSPARSE-library does not return <see cref="F:ManagedCuda.CudaSparse.cusparseStatus.Success"/>.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor">
            <summary>
            
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="serInfo"></param>
            <param name="streamingContext"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(ManagedCuda.CudaSparse.cusparseStatus)">
            <summary>
            
            </summary>
            <param name="error"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(System.String)">
            <summary>
            
            </summary>
            <param name="message"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.#ctor(ManagedCuda.CudaSparse.cusparseStatus,System.String,System.Exception)">
            <summary>
            
            </summary>
            <param name="error"></param>
            <param name="message"></param>
            <param name="exception"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.ToString">
            <summary>
            
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseException.GetObjectData(System.Runtime.Serialization.SerializationInfo,System.Runtime.Serialization.StreamingContext)">
            <summary>
            
            </summary>
            <param name="info"></param>
            <param name="context"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseException.CudaSparseError">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo">
            <summary>
            Wrapper class for cusparseSolveAnalysisInfo
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo.SolveAnalysisInfo">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseContext">
            <summary>
            Wrapper class for cusparseContext. Provides all fundamental API functions as methods.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.#ctor">
            <summary>
            Creates a new CudaSparseContext
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.#ctor(ManagedCuda.BasicTypes.CUstream)">
            <summary>
            Creates a new CudaSparseContext and sets the cuda stream to use
            </summary>
            <param name="stream">A valid CUDA stream created with cudaStreamCreate() (or 0 for the default stream)</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.SetStream(ManagedCuda.BasicTypes.CUstream)">
            <summary>
            Sets the cuda stream to use
            </summary>
            <param name="stream">A valid CUDA stream created with cudaStreamCreate() (or 0 for the default stream)</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GetVersion">
            <summary>
            Returns the version of the underlying CUSPARSE library
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GetPointerMode">
            <summary>
            Returns the pointer mode for scalar values (host or device pointer)
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.SetPointerMode(ManagedCuda.CudaSparse.cusparsePointerMode)">
            <summary>
            Sets the pointer mode for scalar values (host or device pointer)
            </summary>
            <param name="pointerMode"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(System.Single,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(System.Double,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Axpyi(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Addition of a scalar multiple of a sparse vector x and a dense vector y
            </summary>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Double@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Doti(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of a sparse vector x and a dense vector y
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dotci(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            dot product of complex conjugate of a sparse vector x and a dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="result">pointer to the location of the result in the device or host memory.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from dense vector y into sparse vector x.
            </summary>
            <param name="y">vector in dense format (of size >= max(xInd)-idxBase+1).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gthrz(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Gather of non-zero elements from desne vector y into sparse vector x (also replacing these elements in y by zeros).
            </summary>
            <param name="y">vector in dense format with elements indexed by xInd set to zero (it is unchanged if nnz == 0).</param>
            <param name="xVal">vector with nnz non-zero values that were gathered from vector y (that is unchanged if nnz == 0).</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Sctr(ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Scatter of elements of the sparse vector x into dense vector y.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single,System.Single,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Double,System.Double,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Roti(ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Givens rotation, where c and s are cosine and sine, x and y are sparse and dense vectors, respectively.
            </summary>
            <param name="xVal">vector with nnz non-zero values of vector x.</param>
            <param name="xInd">integer vector with nnz indices of the non-zero values of vector x. Length of xInd gives the number nzz passed to CUSPARSE.</param>
            <param name="y">vector in dense format.</param>
            <param name="c">cosine element of the rotation matrix.</param>
            <param name="s">sine element of the rotation matrix.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Single,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Double,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmv(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC,
            and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. 
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="x">vector of n elements if op(A) = A, and m elements if op(A) =
            AT or op(A) = AH.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements if op(A) = A and n elements if op(A) = AT or op(A) = AH.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},System.Single,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},System.Double,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hybmv(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Matrix-vector multiplication  y = alpha * op(A) * x  + beta * y, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="x">vector of n elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of m elements.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in CSR storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal 
            types CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE. </param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvAnalysis``1(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <typeparam name="T">data type: float, double, cuFloatComplex or cuDoubleComplex</typeparam>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type 
            CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.HybsvSolve(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            Solution of triangular linear system op(A) * y = alpha * x, 
            where A is a sparse matrix in HYB storage format, x and y are dense vectors.
            </summary>
            <param name="transA">the operation op(A) (currently only op(A) = A is supported).</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal type CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="info">structure filled with information collected during the analysis phase
            (that should be passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side vector of size m.</param>
            <param name="y">solution vector of size m.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Single,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Double,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrmm(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Matrix-matrix multiplication C = alpha * op(A) * B  + beta * C, where A is a sparse matrix, B and C are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of dense matrices B and C.</param>
            <param name="k">number of columns of sparse matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix types 
            are CUSPARSE_MATRIX_TYPE_GENERAL, CUSPARSE_MATRIX_TYPE_SYMMETRIC, and CUSPARSE_MATRIX_TYPE_HERMITIAN. Also, the
            supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="B">array of dimensions (ldb, n).</param>
            <param name="ldb">leading dimension of B. It must be at least max (1, k) if op(A) = A, and at least max (1, m) otherwise.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, C does not have to be a valid input.</param>
            <param name="C">array of dimensions (ldc, n).</param>
            <param name="ldc">leading dimension of C. It must be at least max (1, m) if op(A) = A and at least max (1, k) otherwise.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmAnalysis(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure filled with information collected during the analysis phase (that should be passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrsmSolve(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Solution of triangular linear system op(A) * Y = alpha * X, with multiple right-hand-sides, where A is a sparse matrix in CSR storage 
            format, X and Y are dense and usually tall matrices.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="n">number of columns of matrix X and Y .</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_TRIANGULAR and diagonal types 
            CUSPARSE_DIAG_TYPE_UNIT and CUSPARSE_DIAG_TYPE_NON_UNIT.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.
            Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="info">structure with information collected during the analysis phase (that should have been passed to the solve phase unchanged).</param>
            <param name="x">right-hand-side array of dimensions (ldx, n).</param>
            <param name="ldx">leading dimension of X (that is >= max(1;m)).</param>
            <param name="y">solution array of dimensions (ldy, n).</param>
            <param name="ldy">leading dimension of Y (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrilu0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-LU factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ LU<para/>
            where A is m*n sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that the diagonal of lower triangular factor L is unitary and need not be stored.
            Therefore the input matrix is ovewritten with the resulting lower and upper triangular
            factor L and U, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csric0(ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseSolveAnalysisInfo)">
            <summary>
            This function computes the incomplete-Cholesky factorization with 0 fill-in and no pivoting <para/>
            op(A) ≈ R'R<para/>
            where A is m*n Hermitian/symmetric positive definite sparse matrix (that is defined in CSR storage format by the three arrays csrValM,
            csrRowPtrA and csrColIndA). <para/>
            Notice that only a lower or upper Hermitian/symmetric part of the matrix A is actually
            stored. It is overwritten by the lower or upper triangular factor R' or R, respectively.<para/>
            A call to this routine must be preceeded by a call to the csrsv_analysis routine.
            This function requires some extra storage. It is executed asynchronously with respect to
            the host and it may return control to the application on the host before the result is ready.
            </summary>
            <param name="trans">the operation op(A).</param>
            <param name="m">number of rows and columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzz passed to CUSPARSE.</param>
            <param name="csrValA_ValM">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero
            elements of matrix A.</param>
            <param name="info">structure with information collected during the analysis phase (that
            should have been passed to the solve phase unchanged).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Gtsv(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            Solution of tridiagonal linear system A * B = B, with multiple right-hand-sides. The coefficient matrix A is 
            composed of lower (dl), main (d) and upper (du) diagonals, and the right-hand-sides B are overwritten with the solution.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="n">number of right-hand-sides, columns of matrix B.</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal
            linear system. The first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The last element of each upper diagonal must be zero.</param>
            <param name="B">dense right-hand-side array of dimensions (ldb, m).</param>
            <param name="ldb">leading dimension of B (that is >= max(1;m)).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.GtsvStridedBatch(System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,System.Int32)">
            <summary>
            Solution of a set of tridiagonal linear systems A * x = x, each with a single right-hand-side. The coefficient 
            matrices A are composed of lower (dl), main (d) and upper (du) diagonals and stored separated by a batchStride, while the 
            right-hand-sides x are also separated by a batchStride.
            </summary>
            <param name="m">the size of the linear system (must be >= 3).</param>
            <param name="dl">dense array containing the lower diagonal of the tri-diagonal 
            linear system. The lower diagonal dl(i) that corresponds to the ith linear system starts at location dl + batchStride * i in memory.
            Also, the first element of each lower diagonal must be zero.</param>
            <param name="d">dense array containing the main diagonal of the tri-diagonal linear system. The main diagonal d(i) that corresponds to the ith
            linear system starts at location d + batchStride * i in memory.</param>
            <param name="du">dense array containing the upper diagonal of the tri-diagonal linear system. The upper diagonal du(i) that corresponds to the ith
            linear system starts at location du + batchStride * i in memory. Also, the last element of each upper diagonal must be zero.</param>
            <param name="x">dense array that contains the right-hand-side of the tridiagonal linear system. The right-hand-side x(i) that corresponds 
            to the ith linear system starts at location x + batchStride * i in memory.</param>
            <param name="batchCount">Number of systems to solve.</param>
            <param name="batchStride">stride (number of elements) that separates the vectors of every system (must be at least m).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Nnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine finds the total number of non-zero elements and the number of non-zero elements per row or column in the dense matrix A.
            </summary>
            <param name="dirA">direction that specifies whether to count non-zero elements by CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRowCol">Output: array of size m or n containing the number of non-zero elements per row or column, respectively.</param>
            <param name="nnzTotalDevHostPtr">Output: total number of non-zero elements in device or host memory.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csr(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSR storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="csrValA">Output: array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">Output: integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of array matrix A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2csc(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This routine converts a dense matrix to a sparse matrix in the CSC storage format, using the information computed by the nnz routine.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerCol">array of size n containing the number of non-zero elements per column.</param>
            <param name="cscValA">Output: array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csc2dense(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in CSC storage format to a dense matrix.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="cscValA">array of nnz (= cscRowPtrA(m)-cscRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="cscRowIndA">integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtrA">integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="A">Output: array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">leading dimension of dense array A.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Xcoo2csr(ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine compresses the indecis of rows or columns. It can be interpreted as a conversion from COO to CSR sparse storage format.
            </summary>
            <param name="cooRowInd">integer array of nnz uncompressed row indices. Length of cooRowInd gives the number nzz passed to CUSPARSE.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="csrRowPtr">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Xcsr2coo(ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine uncompresses the indecis of rows or columns. It can be interpreted as a conversion from CSR to COO sparse storage format.
            </summary>
            <param name="csrRowPtr">Output: integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="m">number of rows of matrix A.</param>
            <param name="cooRowInd">integer array of nnz uncompressed row indices. Length of cooRowInd gives the number nzz passed to CUSPARSE.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2csc(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            This routine converts a matrix from CSR to CSC sparse storage format. The resulting matrix can be re-interpreted as a transpose of the original matrix in CSR storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="csrVal">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtr">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColInd">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A. Length of csrColInd gives the number nzz passed to CUSPARSE.</param>
            <param name="cscVal">Output: array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) nonzero elements of matrix A. It is only filled-in if copyValues is set
            to CUSPARSE_ACTION_NUMERIC.</param>
            <param name="cscRowInd">Output: integer array of nnz (= cscRowPtrA(m) - cscRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="cscColPtr">Output: integer array of n+1 elements that contains the start of every column and the end of the last column plus one.</param>
            <param name="copyValues">CUSPARSE_ACTION_SYMBOLIC or CUSPARSE_ACTION_NUMERIC.</param>
            <param name="idxBase">Index base.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Dense2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a dense matrix to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of the dense matrix A. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="A">array of dimensions (lda, n).</param>
            <param name="lda">leading dimension of dense array A.</param>
            <param name="nnzPerRow">array of size m containing the number of non-zero elements per row.</param>
            <param name="hybA">Output: the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which
            should be less than maximum number of non-zeros per row and is only required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2dense(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},System.Int32)">
            <summary>
            This routine converts a sparse matrix in HYB storage format to a dense matrix.
            </summary>
            <param name="descrA">the descriptor of the matrix A in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="A">array of dimensions (lda, n) that is filled in with the values of the sparse matrix.</param>
            <param name="lda">the matrix A in HYB storage format.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2hyb(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary>
            This routine converts a sparse matrix in CSR storage format to a sparse matrix in HYB storage format.
            </summary>
            <param name="m">number of rows of matrix A.</param>
            <param name="n">number of columns of matrix A.</param>
            <param name="descrA">the descriptor of matrix A in CSR format. The supported matrix type 
            is CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m)-csrRowPtrA(0)) non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column indices of the non-zero elements of matrix A.</param>
            <param name="hybA">the matrix A in HYB storage format.</param>
            <param name="userEllWidth">width of the regular (ELL) part of the matrix in HYB format, which should be less than maximum number of non-zeros per row and is only
            required if partitionType == CUSPARSE_HYB_PARTITION_USER.</param>
            <param name="partitionType">partitioning method to be used in the conversion (please refer to cusparseHybPartition_t on page 15 for details).</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgemmNnz(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgemmNnz(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgemm(ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = op(A) * op(B) <para/>
            where op(A), op(B) and C are m x k, k x n, and m x n sparse matrices (defined in CSR
            storage format by the three arrays csrValA|csrValB|csrValC,
            csrRowPtrA|csrRowPtrB|csrRowPtrC, and csrColIndA|csrColIndB|csrcolIndC)
            respectively. <para/>
            Only support devices of compute capability 2.0 or above.
            </summary>
            <param name="transA">the operation op(A).</param>
            <param name="transB">the operation op(B).</param>
            <param name="m">number of rows of sparse matrix op(A) and C.</param>
            <param name="n">number of columns of sparse matrix op(B) and C.</param>
            <param name="k">number of columns/rows of sparse matrix op(A) / op(B).</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of ~m + 1 elements that contains the start of every row
            and the end of the last row plus one. ~m = m if transA == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~m = k.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of ~k + 1 elements that contains the start of every row
            and the end of the last row plus one. ~k = k if transB == CUSPARSE_
            OPERATION_NON_TRANSPOSE, otherwise ~k = n.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgeamNnz(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.CsrgeamNnz(System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csrgeam(System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function performs following matrix-matrix operation<para/>
            C = alpha * A + beta * B <para/>
            where A, B and C are m x n sparse matrices (defined in CSR storage format by the three
            arrays csrValA|csrValB|csrValC, csrRowPtrA|csrRowPtrB|csrRowPtrC, and
            csrColIndA|csrColIndB|csrcolIndC respectively), and alpha and beta are scalars. Since A and
            B have different sparsity patterns, CUSPARSE adopts two-step approach to complete
            sparse matrix C.
            </summary>
            <param name="m">number of rows of sparse matrix A,B,C.</param>
            <param name="n">number of columns of sparse matrix A,B,C.</param>
            <param name="alpha">scalar used for multiplication.</param> 
            <param name="descrA">the descriptor of matrix A. The supported matrix type is CUSPARSE_
            MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValA">array of nnzA non-zero elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnzA column indices of the non-zero elements of matrix A. Length of csrColIndA gives the number nzzA passed to CUSPARSE.</param>
            <param name="beta">scalar used for multiplication.</param>
            <param name="descrB">the descriptor of matrix B. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValB">array of nnzB non-zero elements of matrix B.</param>
            <param name="csrRowPtrB">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndB">integer array of nnzB column indices of the non-zero elements of matrix B. Length of csrColIndB gives the number nzzB passed to CUSPARSE.</param>
            <param name="descrC">the descriptor of matrix C. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL only.</param>
            <param name="csrValC">array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnzC (= csrRowPtrC(m) - csrRowPtrC(0)) column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Hyb2csr(ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaSparse.CudaSparseHybMat,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in HYB format into a sparse matrix in CSR format.<para/>
            This function requires some amount of temporary storage. It is executed asynchronously
            with respect to the host and it may return control to the application on the host before
            the result is ready.
            </summary>
            <param name="descrA">the descriptor of matrix in Hyb format. The supported matrix type is CUSPARSE_MATRIX_TYPE_GENERAL.</param>
            <param name="hybA">the matrix A in HYB storage format</param>
            <param name="csrValA">array of nnz csrRowPtrA(m) csrRowPtrA(0) non-zero elements of matrix A</param>
            <param name="csrRowPtrA">integer array of m+1 elements that contains the start of every column and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz csrRowPtrA(m) csrRowPtrA(0) column indices of the nonzero elements of matrix .</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsrNnz(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32@)">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="nnzTotalDevHostPtr"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim² non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim² non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim² non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Csr2bsr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in CSR format (that is defined by the three arrays
            csrValA, csrRowPtrA and csrColIndA) into a sparse matrix in BSR format (that is
            defined by arrays bsrValC, bsrRowPtrC, and bsrColIndC).
            A is m x n sparse matrix and C is (mb*blockDim) x (nb*blockDim) sparse matrix.
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="m">number of rows of sparse matrix A.</param>
            <param name="n">number of columns of sparse matrix A.</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="csrValA">array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) non-zero 
            elements of matrix A.</param>
            <param name="csrRowPtrA">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndA">integer array of nnz (= csrRowPtrA(m) - csrRowPtrA(0)) column
            indices of the non-zero elements of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A. The range of blockDim is between
            1 and min(m, n).</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="bsrValC">array of nnzb*blockDim² non-zero elements of matrix C.</param>
            <param name="bsrRowPtrC">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndC">integer array of nnzb column indices of the non-zero blocks of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim² non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim² non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim² non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsr2csr(ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32})">
            <summary>
            This function converts a sparse matrix in BSR format (that is defined by the three arrays
            bsrValA, bsrRowPtrA and bsrColIndA) into a sparse matrix in CSR format (that is
            defined by arrays csrValC, csrRowPtrC, and csrColIndC).
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="mb">number of block rows of sparse matrix A. The number of rows of sparse matrix C is m(= mb*blockDim).</param>
            <param name="nb">number of block columns of sparse matrix A. The number of columns of sparse matrix C is n(= nb*blockDim).</param>
            <param name="descrA">the descriptor of matrix A.</param>
            <param name="bsrValA">array of nnzb*blockDim² non-zero elements of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb column indices of the non-zero blocks of matrix A.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="descrC">the descriptor of matrix C.</param>
            <param name="csrValC">array of nnz (= csrRowPtrC(m) - csrRowPtrC(0)) non-zero elements of matrix C.</param>
            <param name="csrRowPtrC">integer array of m + 1 elements that contains the start of every row
            and the end of the last row plus one.</param>
            <param name="csrColIndC">integer array of nnz column indices of the non-zero elements of matrix C.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},System.Single,ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},System.Double,ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.VectorTypes.cuFloatComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.VectorTypes.cuDoubleComplex,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single},ManagedCuda.CudaDeviceVariable{System.Single})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double},ManagedCuda.CudaDeviceVariable{System.Double})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuFloatComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseContext.Bsrmv(ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{System.Int32},ManagedCuda.CudaDeviceVariable{System.Int32},System.Int32,ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex},ManagedCuda.CudaDeviceVariable{ManagedCuda.VectorTypes.cuDoubleComplex})">
            <summary>
            This function performs the matrix-vector operation <para/>
            y = alpha * op(A) * x + beta * y<para/>
            where A is (mb*blockDim) x (nb*blockDim) sparse matrix (that is defined in BSR
            storage format by the three arrays bsrVal, bsrRowPtr, and bsrColInd), x and y are
            vectors, alpha and beta are scalars. 
            </summary>
            <param name="dirA">storage format of blocks, either CUSPARSE_DIRECTION_ROW or CUSPARSE_DIRECTION_COLUMN.</param>
            <param name="transA">the operation op(A). Only CUSPARSE_OPERATION_NON_TRANSPOSE is supported.</param>
            <param name="mb">number of block rows of matrix A.</param>
            <param name="nb">number of block columns of matrix A.</param>
            <param name="alpha">scalar used for multiplication.</param>
            <param name="descrA">the descriptor of matrix A. The supported matrix type is
            CUSPARSE_MATRIX_TYPE_GENERAL. Also, the supported index bases
            are CUSPARSE_INDEX_BASE_ZERO and CUSPARSE_INDEX_BASE_ONE.</param>
            <param name="bsrValA">array of nnzb (= bsrRowPtr(mb) - bsrRowPtr(0)) non-zero blocks of matrix A.</param>
            <param name="bsrRowPtrA">integer array of mb+1 elements that contains the start of every block
            row and the end of the last block row plus one.</param>
            <param name="bsrColIndA">integer array of nnzb (= bsrRowPtr(m) - bsrRowPtr(0)) column indices of the non-zero blocks of matrix A.
            Length of bsrColIndA gives the number nzzb passed to CUSPARSE.</param>
            <param name="blockDim">block dimension of sparse matrix A, larger than zero.</param>
            <param name="x">vector of nb*blockDim elements.</param>
            <param name="beta">scalar used for multiplication. If beta is zero, y does not have to be a valid input.</param>
            <param name="y">vector of mb*blockDim element.</param>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor">
            <summary>
            Wrapper class for cusparseMatDescr handle.
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.#ctor">
            <summary>
            When the matrix descriptor is created, its fields are initialized to: 
            CUSPARSE_MATRIXYPE_GENERAL
            CUSPARSE_INDEX_BASE_ZERO
            All other fields are uninitialized
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.#ctor(ManagedCuda.CudaSparse.cusparseFillMode,ManagedCuda.CudaSparse.cusparseDiagType)">
            <summary>
            When the matrix descriptor is created, its fields are initialized to: 
            CUSPARSE_MATRIXYPE_GENERAL
            CUSPARSE_INDEX_BASE_ZERO
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.#ctor(ManagedCuda.CudaSparse.cusparseMatrixType,ManagedCuda.CudaSparse.cusparseFillMode,ManagedCuda.CudaSparse.cusparseDiagType,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Creates a new CudaSparseMatrixDescriptor
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatType(ManagedCuda.CudaSparse.cusparseMatrixType)">
            <summary>
            Sets the matrix type
            </summary>
            <param name="type"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatType">
            <summary>
            Returns matrix type
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatFillMode(ManagedCuda.CudaSparse.cusparseFillMode)">
            <summary>
            Sets matrix fill mode
            </summary>
            <param name="fillMode"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatFillMode">
            <summary>
            Returns matrix fill mode
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatDiagType(ManagedCuda.CudaSparse.cusparseDiagType)">
            <summary>
            Sets matrix diagonal type
            </summary>
            <param name="diagType"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatDiagType">
            <summary>
            Returns matrix diagonal type
            </summary>
            <returns></returns>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.SetMatIndexBase(ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary>
            Sets matrix index base
            </summary>
            <param name="indexBase"></param>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.GetMatIndexBase">
            <summary>
            Returns matrix index base.
            </summary>
            <returns></returns>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseMatrixDescriptor.Descriptor">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseHybMat">
            <summary>
            Wrapper class for cusparseHybMat handle
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.#ctor">
            <summary>
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.Finalize">
            <summary>
            For dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.Dispose">
            <summary>
            Dispose
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseHybMat.Dispose(System.Boolean)">
            <summary>
            For IDisposable
            </summary>
            <param name="fDisposing"></param>
        </member>
        <member name="P:ManagedCuda.CudaSparse.CudaSparseHybMat.HybMat">
            <summary>
            Returns the inner handle.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseStatus">
            <summary>
            This is a status type returned by the library functions and it can have the following values.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.Success">
            <summary>
            The operation completed successfully.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.NotInitialized">
            <summary>
            "The CUSPARSE library was not initialized. This is usually caused by the lack of a prior 
            cusparseCreate() call, an error in the CUDA Runtime API called by the CUSPARSE routine, or an 
            error in the hardware setup. To correct: call cusparseCreate() prior to the function call; and
             check that the hardware, an appropriate version of the driver, and the CUSPARSE library are 
            correctly installed.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.AllocFailed">
            <summary>
             "Resource allocation failed inside the CUSPARSE library. This is usually caused by a 
            cudaMalloc() failure. To correct: prior to the function call, deallocate previously allocated
            memory as much as possible.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.InvalidValue">
            <summary>
            "An unsupported value or parameter was passed to the function (a negative vector size, 
            for example). To correct: ensure that all the parameters being passed have valid values.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.ArchMismatch">
            <summary>
            "The function requires a feature absent from the device architecture; usually caused by 
            the lack of support for atomic operations or double precision. To correct: compile and run the
             application on a device with appropriate compute capability, which is 1.1 for 32-bit atomic 
            operations and 1.3 for double precision.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.MappingError">
            <summary>
            "An access to GPU memory space failed, which is usually caused by a failure to bind a texture. 
            To correct: prior to the function call, unbind any previously bound textures.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.ExecutionFailed">
            <summary>
            "The GPU program failed to execute. This is often caused by a launch failure of the kernel on 
            the GPU, which can be caused by multiple reasons. To correct: check that the hardware, an appropriate
             version of the driver, and the CUSPARSE library are correctly installed.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.InternalError">
            <summary>
            "An internal CUSPARSE operation failed. This error is usually caused by a cudaMemcpyAsync() 
            failure. To correct: check that the hardware, an appropriate version of the driver, and the CUSPARSE
             library are correctly installed. Also, check that the memory passed as a parameter to the routine 
            is not being deallocated prior to the routine’s completion.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseStatus.MatrixTypeNotSupported">
            <summary>
            "The matrix type is not supported by this function. This is usually caused by passing an invalid 
            matrix descriptor to the function. To correct: check that the fields in cusparseMatDescr_t descrA were 
            set correctly.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseContext">
            <summary>
            Opaque structure holding CUSPARSE library context
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseContext.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseMatDescr">
            <summary>
            Opaque structure holding the matrix descriptor
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatDescr.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo">
            <summary>
            Opaque structure holding the sparse triangular solve information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseHybMat">
            <summary>
            Opaque structure holding the hybrid (HYB) storage information
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybMat.Handle">
            <summary>
            
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparsePointerMode">
            <summary>
            This type indicates whether the scalar values are passed by reference on the host or device.
            It is important to point out that if several scalar values are passed by reference in the
            function call, all of them will conform to the same single pointer mode. The pointer mode
            can be set and retrieved using <see cref="M:ManagedCuda.CudaSparse.CudaSparseContext.SetPointerMode(ManagedCuda.CudaSparse.cusparsePointerMode)"/> and
            <see cref="M:ManagedCuda.CudaSparse.CudaSparseContext.GetPointerMode"/> routines, respectively.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparsePointerMode.Host">
            <summary>
            Use host pointers.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparsePointerMode.Device">
            <summary>
            Use device pointers.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseAction">
            <summary>
            This type indicates whether the operation is performed only on indices or on data and indices.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseAction.Symbolic">
            <summary>
            the operation is performed only on indices.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseAction.Numeric">
            <summary>
            the operation is performed on data and indices.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseMatrixType">
            <summary>
            This type indicates the type of matrix stored in sparse storage. Notice that for symmetric,
            Hermitian and triangular matrices only their lower or upper part is assumed to be stored.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.General">
            <summary>
            the matrix is general.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.Symmetric">
            <summary>
            the matrix is symmetric.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.Hermitian">
            <summary>
            the matrix is Hermitian.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseMatrixType.Triangular">
            <summary>
            the matrix is triangular.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseFillMode">
            <summary>
            This type indicates if the lower or upper part of a matrix is stored in sparse storage.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseFillMode.Lower">
            <summary>
            the lower triangular part is stored.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseFillMode.Upper">
            <summary>
            the upper triangular part is stored.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseDiagType">
            <summary>
            This type indicates if the matrix diagonal entries are unity. The diagonal elements are
            always assumed to be present, but if CUSPARSE_DIAG_TYPE_UNIT is passed to an API
            routine, then the routine will assume that all diagonal entries are unity and will not read
            or modify those entries. Note that in this case the routine assumes the diagonal entries are
            equal to one, regardless of what those entries are actuall set to in memory.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDiagType.NonUnit">
            <summary>
            the matrix diagonal has non-unit elements.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDiagType.Unit">
            <summary>
            the matrix diagonal has unit elements.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseIndexBase">
            <summary>
            This type indicates if the base of the matrix indices is zero or one.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseIndexBase.Zero">
            <summary>
            the base index is zero.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseIndexBase.One">
            <summary>
            the base index is one.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseOperation">
            <summary>
            This type indicates which operations need to be performed with the sparse matrix.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseOperation.NonTranspose">
            <summary>
            the non-transpose operation is selected.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseOperation.Transpose">
            <summary>
            the transpose operation is selected.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseOperation.ConjugateTranspose">
            <summary>
            the conjugate transpose operation is selected.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseDirection">
            <summary>
            This type indicates whether the elements of a dense matrix should be parsed by rows or by
            columns (assuming column-major storage in memory of the dense matrix).
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDirection.Row">
            <summary>
            the matrix should be parsed by rows.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseDirection.Column">
            <summary>
            the matrix should be parsed by columns.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.cusparseHybPartition">
            <summary>
            This type indicates how to perform the partitioning of the matrix into regular (ELL) and
            irregular (COO) parts of the HYB format.<para/>
            The partitioning is performed during the conversion of the matrix from a dense or sparse
            format into the HYB format and is governed by the following rules. When
            CUSPARSE_HYB_PARTITION_AUTO is selected, the CUSPARSE library automatically decides
            how much data to put into the regular and irregular parts of the HYB format. When
            CUSPARSE_HYB_PARTITION_USER is selected, the width of the regular part of the HYB
            format should be specified by the caller. When CUSPARSE_HYB_PARTITION_MAX is selected,
            the width of the regular part of the HYB format equals to the maximum number of
            non-zero elements per row, in other words, the entire matrix is stored in the regular part of
            the HYB format.<para/>
            The default is to let the library automatically decide how to split the data.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybPartition.Auto">
            <summary>
            the automatic partitioning is selected (default).
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybPartition.User">
            <summary>
            the user specified treshold is used.
            </summary>
        </member>
        <member name="F:ManagedCuda.CudaSparse.cusparseHybPartition.Max">
            <summary>
            the data is stored in ELL format.
            </summary>
        </member>
        <member name="T:ManagedCuda.CudaSparse.CudaSparseNativeMethods">
            <summary>
            C# wrapper for cusparse_v2.h
            </summary>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreate(ManagedCuda.CudaSparse.cusparseContext@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroy(ManagedCuda.CudaSparse.cusparseContext)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetVersion(ManagedCuda.CudaSparse.cusparseContext,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetStream(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.BasicTypes.CUstream)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetPointerMode(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparsePointerMode@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetPointerMode(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparsePointerMode)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateMatDescr(ManagedCuda.CudaSparse.cusparseMatDescr@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyMatDescr(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatType(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseMatrixType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatType(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatFillMode(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseFillMode)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatFillMode(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatDiagType(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseDiagType)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatDiagType(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSetMatIndexBase(ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseGetMatIndexBase(ManagedCuda.CudaSparse.cusparseMatDescr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateSolveAnalysisInfo(ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroySolveAnalysisInfo(ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCreateHybMat(ManagedCuda.CudaSparse.cusparseHybMat@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDestroyHybMat(ManagedCuda.CudaSparse.cusparseHybMat)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZaxpyi_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdoti(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdotci(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgthr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgthrz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZsctr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSroti_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,System.Single@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDroti_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,System.Double@,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSroti_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDroti_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmv_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv_analysis_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv_analysis_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv_analysis_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv_analysis_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsv_solve_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybsv_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhybsv_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrmm_v2(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsm_analysis(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrsm_solve(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrilu0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsric0(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseSolveAnalysisInfo)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgtsv(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZgtsvStridedBatch(ManagedCuda.CudaSparse.cusparseContext,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZnnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdense2csr(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdense2csc(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsc2dense(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcoo2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2coo(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2csc_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2csc_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2csc_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2csc_v2(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseAction,ManagedCuda.CudaSparse.cusparseIndexBase)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZdense2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhyb2dense(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2hyb(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseHybMat,System.Int32,ManagedCuda.CudaSparse.cusparseHybPartition)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgemmNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgemmNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgemm(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseOperation,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgeamNnz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsrgeamNnz(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsrgeam(ManagedCuda.CudaSparse.cusparseContext,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseShyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDhyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseChyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZhyb2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.CudaSparse.cusparseHybMat,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2bsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseXcsr2bsrNnz(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32@)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseScsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDcsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCcsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZcsr2bsr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsr2csr(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,System.Int32,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Single@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Single@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,System.Double@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,System.Double@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuFloatComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.VectorTypes.cuDoubleComplex@,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseSbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseDbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseCbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
        <member name="M:ManagedCuda.CudaSparse.CudaSparseNativeMethods.cusparseZbsrxmv(ManagedCuda.CudaSparse.cusparseContext,ManagedCuda.CudaSparse.cusparseDirection,ManagedCuda.CudaSparse.cusparseOperation,System.Int32,System.Int32,System.Int32,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.CudaSparse.cusparseMatDescr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,System.Int32,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr,ManagedCuda.BasicTypes.CUdeviceptr)">
            <summary/>
        </member>
    </members>
</doc>
